#!/usr/bin/env tsx
import { generateRandomString } from 'better-auth/crypto'
import { scrypt } from 'crypto'
import { addDays, format, startOfDay } from 'date-fns'
import { config } from 'dotenv'
import { eq } from 'drizzle-orm'
import { drizzle } from 'drizzle-orm/node-postgres'
import * as fs from 'fs'
import * as path from 'path'
import { resolve } from 'path'
import { Pool } from 'pg'
import { promisify } from 'util'

import { db } from '../src/lib/database'
import { createLogger } from '../src/lib/logger'
import * as schema from '../src/lib/schema'

// Load environment variables from .env.local BEFORE importing anything that uses them
config({ path: resolve(process.cwd(), '.env.local') })

const logger = createLogger('database-seed')

// Password hashing using scrypt (matching Better Auth's default)
const scryptAsync = promisify(scrypt)

async function defaultHash(password: string): Promise<string> {
  const salt = generateRandomString(16)
  const hash = (await scryptAsync(password, salt, 32)) as Buffer
  return `${salt}:${hash.toString('hex')}`
}

// Environment management functions
function updateEnvLocal(testUsers: ReturnType<typeof getTestUsersData>) {
  const envPath = resolve(process.cwd(), '.env.local')
  let envContent = ''

  // Read existing .env.local if it exists
  if (fs.existsSync(envPath)) {
    envContent = fs.readFileSync(envPath, 'utf8')
  }

  // Remove existing test user credentials from env content
  const testUserKeys = [
    'TEST_COACH_EMAIL',
    'TEST_COACH_PASSWORD',
    'TEST_COACH2_EMAIL',
    'TEST_COACH2_PASSWORD',
    'TEST_RUNNER_EMAIL',
    'TEST_RUNNER_PASSWORD',
    'TEST_RUNNER2_EMAIL',
    'TEST_RUNNER2_PASSWORD',
  ]

  // Remove old test user lines
  const lines = envContent.split('\n').filter(line => {
    const key = line.split('=')[0]
    return !testUserKeys.includes(key) && !line.startsWith('# Test user credentials')
  })

  // Add updated test user credentials
  lines.push('')
  lines.push('# Test user credentials (auto-generated by seed script)')

  const roleCounters = { coach: 0, runner: 0 }
  testUsers.forEach(user => {
    roleCounters[user.role]++
    const role = user.role.toUpperCase()
    const suffix = roleCounters[user.role] > 1 ? roleCounters[user.role].toString() : ''
    const roleKey = `${role}${suffix}`

    lines.push(`TEST_${roleKey}_EMAIL=${user.email}`)
    lines.push(`TEST_${roleKey}_PASSWORD=${user.password}`)
  })

  lines.push('')

  // Write updated content back to .env.local
  fs.writeFileSync(envPath, lines.join('\n'))
  logger.info(`‚úÖ Updated .env.local with test user credentials`)
}

function cleanupPasswordFiles() {
  const passwordFiles = [
    'test-passwords.txt',
    'user-credentials.txt',
    'generated-passwords.txt',
    'seed-passwords.txt',
  ]

  let cleanedCount = 0
  passwordFiles.forEach(filename => {
    const filepath = resolve(process.cwd(), filename)
    if (fs.existsSync(filepath)) {
      fs.unlinkSync(filepath)
      cleanedCount++
      logger.info(`üóëÔ∏è Removed password file: ${filename}`)
    }
  })

  // Also check in common directories
  const checkDirs = ['supabase', 'scripts', 'docs']
  checkDirs.forEach(dir => {
    const dirPath = resolve(process.cwd(), dir)
    if (fs.existsSync(dirPath)) {
      passwordFiles.forEach(filename => {
        const filepath = path.join(dirPath, filename)
        if (fs.existsSync(filepath)) {
          fs.unlinkSync(filepath)
          cleanedCount++
          logger.info(`üóëÔ∏è Removed password file: ${dir}/${filename}`)
        }
      })
    }
  })

  if (cleanedCount > 0) {
    logger.info(`‚úÖ Cleaned up ${cleanedCount} password files`)
  } else {
    logger.info('‚ÑπÔ∏è No password files found to clean up')
  }
}

// Training phases data - using schema field names (camelCase)
const trainingPhasesData = [
  {
    name: 'Base Building',
    description:
      'Aerobic base development with high volume, low intensity running. Focus on time on feet and building mitochondrial density.',
    phaseOrder: 1,
    typicalDurationWeeks: 8,
    focusAreas: ['aerobic_base', 'volume', 'consistency', 'injury_prevention'],
  },
  {
    name: 'Build Phase',
    description:
      'Introduction of race-specific workouts including tempo runs, intervals, and hill training. Maintain base while adding intensity.',
    phaseOrder: 2,
    typicalDurationWeeks: 6,
    focusAreas: ['lactate_threshold', 'vo2_max', 'race_pace', 'strength'],
  },
  {
    name: 'Peak Phase',
    description:
      'Highest training load with race simulation workouts. Practice race-day nutrition and pacing strategies.',
    phaseOrder: 3,
    typicalDurationWeeks: 3,
    focusAreas: ['race_simulation', 'peak_fitness', 'race_practice', 'mental_preparation'],
  },
  {
    name: 'Taper',
    description:
      'Reduce training volume while maintaining intensity. Allow body to recover and absorb training adaptations.',
    phaseOrder: 4,
    typicalDurationWeeks: 2,
    focusAreas: ['recovery', 'race_readiness', 'mental_preparation', 'race_logistics'],
  },
  {
    name: 'Recovery',
    description:
      'Post-race recovery with easy running or cross-training. Focus on physical and mental restoration.',
    phaseOrder: 5,
    typicalDurationWeeks: 2,
    focusAreas: ['recovery', 'regeneration', 'reflection', 'planning'],
  },
]

// Plan templates data (basic set) - using schema field names (camelCase)
const planTemplatesData = [
  {
    name: '50K Training Plan - Beginner',
    description:
      'A 16-week beginner-friendly 50K ultramarathon training plan focusing on gradual volume increases and race preparation.',
    distanceType: '50K',
    durationWeeks: 16,
    difficultyLevel: 'beginner',
    peakWeeklyMiles: '45', // String for decimal type
    minBaseMiles: '25', // String for decimal type
    isPublic: true,
    tags: ['50K', 'beginner', 'first_ultra'],
  },
  {
    name: '50K Training Plan - Intermediate',
    description:
      'A 20-week intermediate 50K plan with structured workouts and hill training for experienced runners.',
    distanceType: '50K',
    durationWeeks: 20,
    difficultyLevel: 'intermediate',
    peakWeeklyMiles: '60',
    minBaseMiles: '35',
    isPublic: true,
    tags: ['50K', 'intermediate', 'structured'],
  },
  {
    name: '50M Training Plan - Intermediate',
    description:
      'A 24-week 50-mile training plan with back-to-back long runs and race-specific preparation.',
    distanceType: '50M',
    durationWeeks: 24,
    difficultyLevel: 'intermediate',
    peakWeeklyMiles: '75',
    minBaseMiles: '45',
    isPublic: true,
    tags: ['50M', 'intermediate', 'back_to_back'],
  },
  {
    name: '100K Training Plan - Advanced',
    description:
      'A 28-week advanced 100K plan with high volume, technical terrain training, and periodization.',
    distanceType: '100K',
    durationWeeks: 28,
    difficultyLevel: 'advanced',
    peakWeeklyMiles: '90',
    minBaseMiles: '60',
    isPublic: true,
    tags: ['100K', 'advanced', 'high_volume'],
  },
]

// Test users data - using environment variables for security
function getTestUsersData() {
  // Generate secure random passwords if not provided
  const generateSecurePassword = () => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*'
    let result = ''
    for (let i = 0; i < 16; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length))
    }
    return result
  }

  return [
    {
      email: process.env.TEST_COACH_EMAIL || 'coach1@ultracoach.dev',
      password: process.env.TEST_COACH_PASSWORD || generateSecurePassword(),
      name: 'Elena Rodriguez',
      fullName: 'Elena Rodriguez',
      role: 'coach' as const,
    },
    {
      email: process.env.TEST_COACH2_EMAIL || 'coach2@ultracoach.dev',
      password: process.env.TEST_COACH2_PASSWORD || generateSecurePassword(),
      name: 'Sarah Mountain',
      fullName: 'Sarah Mountain',
      role: 'coach' as const,
    },
    {
      email: process.env.TEST_RUNNER_EMAIL || 'testrunner@ultracoach.dev',
      password: process.env.TEST_RUNNER_PASSWORD || generateSecurePassword(),
      name: 'Alex Trail',
      fullName: 'Alex Trail',
      role: 'runner' as const,
    },
    {
      email: process.env.TEST_RUNNER2_EMAIL || 'runner2@ultracoach.dev',
      password: process.env.TEST_RUNNER2_PASSWORD || generateSecurePassword(),
      name: 'Mike Trailblazer',
      fullName: 'Mike Trailblazer',
      role: 'runner' as const,
    },
  ]
}

// --- Database Setup ---
// Use the unified database connection from our main database module
// This ensures consistency with Better Auth and the rest of the application

// --- Static Data Functions ---
async function seedStaticData() {
  // Use the unified database connection
  logger.info('üìã Seeding static data (training phases and plan templates)...')

  // Seed training phases
  for (const phaseData of trainingPhasesData) {
    try {
      const existingPhase = await db
        .select()
        .from(schema.training_phases)
        .where(eq(schema.training_phases.name, phaseData.name))
        .limit(1)

      if (existingPhase.length > 0) {
        logger.info(`Training phase "${phaseData.name}" already exists, skipping...`)
        continue
      }

      await db.insert(schema.training_phases).values(phaseData)
      logger.info(`‚úÖ Created training phase: ${phaseData.name}`)
    } catch (error) {
      logger.error(`‚ùå Failed to create training phase "${phaseData.name}":`, error)
    }
  }

  // Seed plan templates
  for (const templateData of planTemplatesData) {
    try {
      const existingTemplate = await db
        .select()
        .from(schema.plan_templates)
        .where(eq(schema.plan_templates.name, templateData.name))
        .limit(1)

      if (existingTemplate.length > 0) {
        logger.info(`Plan template "${templateData.name}" already exists, skipping...`)
        continue
      }

      // Transform the data to match the database schema
      const dbTemplateData = {
        name: templateData.name,
        description: templateData.description,
        distance_type: templateData.distanceType,
        duration_weeks: templateData.durationWeeks,
        difficulty_level: templateData.difficultyLevel,
        peak_weekly_miles: templateData.peakWeeklyMiles,
        min_base_miles: templateData.minBaseMiles,
        is_public: templateData.isPublic,
        tags: templateData.tags,
      }

      await db.insert(schema.plan_templates).values(dbTemplateData)
      logger.info(`‚úÖ Created plan template: ${templateData.name}`)
    } catch (error) {
      logger.error(`‚ùå Failed to create plan template "${templateData.name}":`, error)
    }
  }
}

// --- Better Auth User Creation ---
async function seedTestUsers() {
  // Use the unified database connection
  logger.info('üë• Creating test users using Better Auth Admin API...')

  // Security warning for production
  if (process.env.NODE_ENV === 'production') {
    logger.warn('‚ö†Ô∏è  WARNING: Creating test users in production environment!')
    logger.warn('‚ö†Ô∏è  Ensure test user credentials are secure and monitored!')
  }

  const testUsersData = getTestUsersData()

  // Import Better Auth instance
  const { auth } = await import('../src/lib/better-auth')

  for (const userData of testUsersData) {
    try {
      logger.info(`Creating user: ${userData.email}`)

      // Check if user already exists first
      const existingUser = await db
        .select()
        .from(schema.user)
        .where(eq(schema.user.email, userData.email))
        .limit(1)

      if (existingUser.length > 0) {
        logger.info(`User ${userData.email} already exists, skipping...`)
        continue
      }

      // Use direct database insertion with Better Auth patterns
      // Generate a proper user ID
      const userId = generateRandomString(10)

      // Insert user directly into database
      await db.insert(schema.user).values({
        id: userId,
        email: userData.email,
        name: userData.name,
        role: userData.role,
        fullName: userData.fullName,
        emailVerified: false, // Set appropriate verification status
        createdAt: new Date(),
        updatedAt: new Date(),
      })

      logger.info(`‚úÖ Created user: ${userData.email} (${userData.role})`)

      // Create credential account for password authentication
      // Import Better Auth instance to access password hashing
      const { auth } = await import('../src/lib/better-auth')

      // Use Better Auth's internal password hashing
      const hashedPassword =
        (await auth.options.emailAndPassword?.password?.hash?.(userData.password)) ||
        (await defaultHash(userData.password))

      await db.insert(schema.account).values({
        id: generateRandomString(10),
        accountId: userId, // Link to the user
        providerId: 'credential', // Important: Must be 'credential' for email/password
        userId: userId,
        password: hashedPassword,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      logger.info(`‚úÖ Created credential account for: ${userData.email}`)
    } catch (error) {
      logger.error(`üö® EXCEPTION while creating user ${userData.email}:`, error)
    }
  }
}

// --- Training Plans & Sample Data Seeding ---
async function createSampleTrainingPlan() {
  // Use the unified database connection
  logger.info('üèÉ Creating sample training plans with coach-runner relationships...')

  // Get coach and runners
  const users = await db.select().from(schema.user)
  const coaches = users.filter(user => user.role === 'coach')
  const runners = users.filter(user => user.role === 'runner')

  if (coaches.length === 0 || runners.length === 0) {
    logger.warn('‚ö†Ô∏è No coaches or runners found - skipping training plan creation')
    return
  }

  // Create multiple training plans with proper relationships
  const trainingPlansData = [
    {
      title: '100 Mile Ultra Training - Spring Peak',
      description:
        'Comprehensive 24-week training plan targeting a 100-mile ultramarathon with periodized training phases.',
      coach_id: coaches[0].id, // Elena Rodriguez
      runner_id: runners[0].id, // Alex Trail
      target_race_date: new Date('2025-09-15'),
      target_race_distance: '100 miles',
    },
    {
      title: '50K Trail Race Preparation',
      description:
        '16-week plan focused on trail running techniques, elevation training, and race strategy.',
      coach_id: coaches[1] ? coaches[1].id : coaches[0].id, // Sarah Mountain or Elena
      runner_id: runners[1] ? runners[1].id : runners[0].id, // Mike Trailblazer or Alex
      target_race_date: new Date('2025-07-20'),
      target_race_distance: '50K',
    },
    {
      title: 'Ultra Marathon Base Building',
      description:
        'Foundation phase training plan for ultra distance preparation with gradual mileage increases.',
      coach_id: coaches[0].id, // Elena Rodriguez (coaches both runners)
      runner_id: runners[1] ? runners[1].id : runners[0].id, // Mike Trailblazer or Alex
      target_race_date: new Date('2025-10-01'),
      target_race_distance: '50 miles',
    },
  ]

  for (const planData of trainingPlansData) {
    try {
      const existingPlan = await db
        .select()
        .from(schema.training_plans)
        .where(eq(schema.training_plans.title, planData.title))
        .limit(1)

      if (existingPlan.length > 0) {
        logger.info(`Training plan "${planData.title}" already exists, skipping...`)
        continue
      }

      const [newPlan] = await db.insert(schema.training_plans).values(planData).returning()
      const coach = coaches.find(c => c.id === planData.coach_id)
      const runner = runners.find(r => r.id === planData.runner_id)
      logger.info(
        `‚úÖ Created training plan: "${planData.title}" (Coach: ${coach?.email}, Runner: ${runner?.email})`
      )

      // Create sample workouts for each training plan
      await seedSampleWorkouts(newPlan.id, planData.title)
    } catch (error) {
      logger.error(`üö® Failed to create training plan "${planData.title}":`, error)
    }
  }
}

// --- Sample Workouts Seeding ---
async function seedSampleWorkouts(trainingPlanId: string, planTitle: string) {
  // Use the unified database connection
  const currentDate = new Date()

  const workoutsData = [
    {
      training_plan_id: trainingPlanId,
      date: startOfDay(addDays(currentDate, 1)), // Tomorrow
      planned_distance: '5.00',
      planned_duration: 45, // 45 minutes (stored as minutes)
      planned_type: 'Easy Run',
      status: 'planned' as const,
      // Enhanced workout fields
      category: 'easy',
      intensity: 3,
      terrain: 'road',
      elevation_gain: 100,
    },
    {
      training_plan_id: trainingPlanId,
      date: startOfDay(addDays(currentDate, 3)), // 3 days from now
      planned_distance: '8.00',
      planned_duration: 60, // 60 minutes
      planned_type: 'Tempo Run',
      status: 'planned' as const,
      // Enhanced workout fields
      category: 'tempo',
      intensity: 7,
      terrain: 'road',
      elevation_gain: 200,
    },
    {
      training_plan_id: trainingPlanId,
      date: startOfDay(addDays(currentDate, 6)), // 6 days from now
      planned_distance: '12.00',
      planned_duration: 90, // 90 minutes
      planned_type: 'Long Run',
      status: 'planned' as const,
      // Enhanced workout fields
      category: 'long_run',
      intensity: 5,
      terrain: 'trail',
      elevation_gain: 500,
    },
  ]

  try {
    await db.insert(schema.workouts).values(workoutsData)
    logger.info(`  ‚úÖ Added ${workoutsData.length} sample workouts for "${planTitle}"`)
    logger.info(
      `  üìÖ Workout dates: ${workoutsData.map(w => format(w.date, 'yyyy-MM-dd')).join(', ')}`
    )
  } catch (error) {
    logger.error(`  ‚ùå Failed to create sample workouts for "${planTitle}":`, error)
  }
}

// --- Conversations Seeding ---
async function seedConversations() {
  // Use the unified database connection
  logger.info('üí¨ Creating sample conversations between coaches and runners...')

  // Get all users and training plans
  const users = await db.select().from(schema.user)
  const coaches = users.filter(user => user.role === 'coach')
  const runners = users.filter(user => user.role === 'runner')
  const trainingPlans = await db.select().from(schema.training_plans)

  if (coaches.length === 0 || runners.length === 0 || trainingPlans.length === 0) {
    logger.warn('‚ö†Ô∏è Insufficient data for conversations - skipping conversation creation')
    return
  }

  // Create conversations
  const conversationsData = [
    {
      coach_id: coaches[0].id, // Elena Rodriguez
      runner_id: runners[0].id, // Alex Trail
      training_plan_id: trainingPlans[0].id,
      title: 'Training Progress Check-in',
    },
    {
      coach_id: coaches[1].id, // Sarah Mountain
      runner_id: runners[1].id, // Mike Trailblazer
      training_plan_id: trainingPlans[1].id,
      title: 'Trail Running Technique Discussion',
    },
  ]

  for (const convData of conversationsData) {
    try {
      const existingConv = await db
        .select()
        .from(schema.conversations)
        .where(eq(schema.conversations.title, convData.title))
        .limit(1)

      if (existingConv.length > 0) {
        logger.info(`Conversation "${convData.title}" already exists, skipping...`)
        continue
      }

      const [newConv] = await db.insert(schema.conversations).values(convData).returning()
      const coach = coaches.find(c => c.id === convData.coach_id)
      const runner = runners.find(r => r.id === convData.runner_id)
      logger.info(
        `‚úÖ Created conversation: "${convData.title}" (${coach?.name} ‚Üî ${runner?.name})`
      )
    } catch (error) {
      logger.error(`üö® Failed to create conversation "${convData.title}":`, error)
    }
  }
}

// --- Main Execution ---
async function main() {
  const startTime = Date.now()

  try {
    logger.info('üå± Starting UltraCoach database seeding...')

    // Clean up old password files first
    cleanupPasswordFiles()

    // Get test user data and update .env.local
    const testUsersData = getTestUsersData()
    updateEnvLocal(testUsersData)

    // Seed static data first
    await seedStaticData()

    // Create test users
    await seedTestUsers()

    // Create sample training plans with relationships
    await createSampleTrainingPlan()

    // Create sample conversations
    await seedConversations()

    // Show summary
    logger.info('üìä Database summary:')
    const userCount = await db
      .select()
      .from(schema.user)
      .then(r => r.length)
    const planCount = await db
      .select()
      .from(schema.training_plans)
      .then(r => r.length)
    const workoutCount = await db
      .select()
      .from(schema.workouts)
      .then(r => r.length)
    const phaseCount = await db
      .select()
      .from(schema.training_phases)
      .then(r => r.length)
    const templateCount = await db
      .select()
      .from(schema.plan_templates)
      .then(r => r.length)

    console.log(`
    üìä Seeding Results:
    ‚îú‚îÄ‚îÄ Users: ${userCount}
    ‚îú‚îÄ‚îÄ Training Plans: ${planCount}
    ‚îú‚îÄ‚îÄ Workouts: ${workoutCount}
    ‚îú‚îÄ‚îÄ Training Phases: ${phaseCount}
    ‚îî‚îÄ‚îÄ Plan Templates: ${templateCount}
    `)

    // Database connection will be cleaned up automatically by the unified database module

    const duration = Date.now() - startTime
    logger.info(`‚úÖ Database seeding completed in ${duration}ms`)

    console.log(`
    üéØ Database seeding completed successfully!
    ‚Ä¢ Test users created with secure credentials
    ‚Ä¢ Coach-runner relationships established
    ‚Ä¢ Training plans and sample workouts added
    ‚Ä¢ Credentials saved to .env.local for easy testing
    ‚Ä¢ Old password files cleaned up for security
    `)
  } catch (error) {
    logger.error('‚ùå Database seeding failed:', error)
    // In test environment, don't exit process
    if (process.env.NODE_ENV === 'test') {
      throw error
    }
    process.exit(1)
  }
}

// Only run main() if not in test environment or when required directly
if (process.env.NODE_ENV !== 'test' && require.main === module) {
  main()
}

// Export for testing
export { main as seedDatabase }
