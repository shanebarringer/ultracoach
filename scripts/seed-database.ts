#!/usr/bin/env tsx
import { generateRandomString } from 'better-auth/crypto'
import { scrypt } from 'crypto'
// Add the randomUUID import for generating UUIDs
import { randomUUID } from 'crypto'
import { addDays, format, startOfDay } from 'date-fns'
import { config } from 'dotenv'
import { and, eq } from 'drizzle-orm'
import { drizzle } from 'drizzle-orm/node-postgres'
import * as fs from 'fs'
import * as path from 'path'
import { resolve } from 'path'
import { Pool } from 'pg'
import { promisify } from 'util'

import { db } from '../src/lib/database'
import { createLogger } from '../src/lib/logger'
import * as schema from '../src/lib/schema'

// Load environment variables from .env.local BEFORE importing anything that uses them
config({ path: resolve(process.cwd(), '.env.local') })

const logger = createLogger('database-seed')

// Password hashing using scrypt (matching Better Auth's default)
const scryptAsync = promisify(scrypt)

async function defaultHash(password: string): Promise<string> {
  const salt = generateRandomString(16)
  const hash = (await scryptAsync(password, salt, 32)) as Buffer
  return `${salt}:${hash.toString('hex')}`
}

// Environment management functions
function updateEnvLocal(testUsers: ReturnType<typeof getTestUsersData>) {
  const envPath = resolve(process.cwd(), '.env.local')
  let envContent = ''

  // Read existing .env.local if it exists
  if (fs.existsSync(envPath)) {
    envContent = fs.readFileSync(envPath, 'utf8')
  }

  // Remove existing test user credentials from env content
  const testUserKeys = [
    'TEST_COACH_EMAIL',
    'TEST_COACH_PASSWORD',
    'TEST_COACH2_EMAIL',
    'TEST_COACH2_PASSWORD',
    'TEST_RUNNER_EMAIL',
    'TEST_RUNNER_PASSWORD',
    'TEST_RUNNER2_EMAIL',
    'TEST_RUNNER2_PASSWORD',
  ]

  // Remove old test user lines
  const lines = envContent.split('\n').filter(line => {
    const key = line.split('=')[0]
    return !testUserKeys.includes(key) && !line.startsWith('# Test user credentials')
  })

  // Add updated test user credentials
  lines.push('')
  lines.push('# Test user credentials (auto-generated by seed script)')

  const roleCounters = { coach: 0, runner: 0 }
  testUsers.forEach(user => {
    roleCounters[user.role]++
    const role = user.role.toUpperCase()
    const suffix = roleCounters[user.role] > 1 ? roleCounters[user.role].toString() : ''
    const roleKey = `${role}${suffix}`

    lines.push(`TEST_${roleKey}_EMAIL=${user.email}`)
    lines.push(`TEST_${roleKey}_PASSWORD=${user.password}`)
  })

  lines.push('')

  // Write updated content back to .env.local
  fs.writeFileSync(envPath, lines.join('\n'))
  logger.info(`‚úÖ Updated .env.local with test user credentials`)
}

function cleanupPasswordFiles() {
  const passwordFiles = [
    'test-passwords.txt',
    'user-credentials.txt',
    'generated-passwords.txt',
    'seed-passwords.txt',
  ]

  let cleanedCount = 0
  passwordFiles.forEach(filename => {
    const filepath = resolve(process.cwd(), filename)
    if (fs.existsSync(filepath)) {
      fs.unlinkSync(filepath)
      cleanedCount++
      logger.info(`üóëÔ∏è Removed password file: ${filename}`)
    }
  })

  // Also check in common directories
  const checkDirs = ['supabase', 'scripts', 'docs']
  checkDirs.forEach(dir => {
    const dirPath = resolve(process.cwd(), dir)
    if (fs.existsSync(dirPath)) {
      passwordFiles.forEach(filename => {
        const filepath = path.join(dirPath, filename)
        if (fs.existsSync(filepath)) {
          fs.unlinkSync(filepath)
          cleanedCount++
          logger.info(`üóëÔ∏è Removed password file: ${dir}/${filename}`)
        }
      })
    }
  })

  if (cleanedCount > 0) {
    logger.info(`‚úÖ Cleaned up ${cleanedCount} password files`)
  } else {
    logger.info('‚ÑπÔ∏è No password files found to clean up')
  }
}

// Training phases data - using schema field names (camelCase)
const trainingPhasesData = [
  {
    name: 'Base Building',
    description:
      'Aerobic base development with high volume, low intensity running. Focus on time on feet and building mitochondrial density.',
    phaseOrder: 1,
    typicalDurationWeeks: 8,
    focusAreas: ['aerobic_base', 'volume', 'consistency', 'injury_prevention'],
  },
  {
    name: 'Build Phase',
    description:
      'Introduction of race-specific workouts including tempo runs, intervals, and hill training. Maintain base while adding intensity.',
    phaseOrder: 2,
    typicalDurationWeeks: 6,
    focusAreas: ['lactate_threshold', 'vo2_max', 'race_pace', 'strength'],
  },
  {
    name: 'Peak Phase',
    description:
      'Highest training load with race simulation workouts. Practice race-day nutrition and pacing strategies.',
    phaseOrder: 3,
    typicalDurationWeeks: 3,
    focusAreas: ['race_simulation', 'peak_fitness', 'race_practice', 'mental_preparation'],
  },
  {
    name: 'Taper',
    description:
      'Reduce training volume while maintaining intensity. Allow body to recover and absorb training adaptations.',
    phaseOrder: 4,
    typicalDurationWeeks: 2,
    focusAreas: ['recovery', 'race_readiness', 'mental_preparation', 'race_logistics'],
  },
  {
    name: 'Recovery',
    description:
      'Post-race recovery with easy running or cross-training. Focus on physical and mental restoration.',
    phaseOrder: 5,
    typicalDurationWeeks: 2,
    focusAreas: ['recovery', 'regeneration', 'reflection', 'planning'],
  },
]

// Plan templates data (basic set) - using schema field names (camelCase)
const planTemplatesData = [
  {
    name: '50K Training Plan - Beginner',
    description:
      'A 16-week beginner-friendly 50K ultramarathon training plan focusing on gradual volume increases and race preparation.',
    distanceType: '50K',
    durationWeeks: 16,
    difficultyLevel: 'beginner',
    peakWeeklyMiles: '45', // String for decimal type
    minBaseMiles: '25', // String for decimal type
    isPublic: true,
    tags: ['50K', 'beginner', 'first_ultra'],
  },
  {
    name: '50K Training Plan - Intermediate',
    description:
      'A 20-week intermediate 50K plan with structured workouts and hill training for experienced runners.',
    distanceType: '50K',
    durationWeeks: 20,
    difficultyLevel: 'intermediate',
    peakWeeklyMiles: '60',
    minBaseMiles: '35',
    isPublic: true,
    tags: ['50K', 'intermediate', 'structured'],
  },
  {
    name: '50M Training Plan - Intermediate',
    description:
      'A 24-week 50-mile training plan with back-to-back long runs and race-specific preparation.',
    distanceType: '50M',
    durationWeeks: 24,
    difficultyLevel: 'intermediate',
    peakWeeklyMiles: '75',
    minBaseMiles: '45',
    isPublic: true,
    tags: ['50M', 'intermediate', 'back_to_back'],
  },
  {
    name: '100K Training Plan - Advanced',
    description:
      'A 28-week advanced 100K plan with high volume, technical terrain training, and periodization.',
    distanceType: '100K',
    durationWeeks: 28,
    difficultyLevel: 'advanced',
    peakWeeklyMiles: '90',
    minBaseMiles: '60',
    isPublic: true,
    tags: ['100K', 'advanced', 'high_volume'],
  },
]

// Comprehensive test users data - using environment variables for security
function getTestUsersData() {
  const generateSecurePassword = () => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*'
    let result = ''
    for (let i = 0; i < 16; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length))
    }
    return result
  }

  // Coaches
  const coaches = [
    {
      email: process.env.TEST_COACH_EMAIL || 'sarah@ultracoach.dev',
      password: process.env.TEST_COACH_PASSWORD || 'UltraCoach2025!',
      name: 'Sarah Mountain',
      fullName: 'Sarah Mountain',
      role: 'coach' as const,
    },
    {
      email: process.env.TEST_COACH2_EMAIL || 'marcus@ultracoach.dev',
      password: process.env.TEST_COACH2_PASSWORD || 'UltraCoach2025!',
      name: 'Marcus Trail',
      fullName: 'Marcus Trail',
      role: 'coach' as const,
    },
    {
      email: process.env.TEST_COACH3_EMAIL || 'emma@ultracoach.dev',
      password: process.env.TEST_COACH3_PASSWORD || 'UltraCoach2025!',
      name: 'Emma Summit',
      fullName: 'Emma Summit',
      role: 'coach' as const,
    },
  ]

  // Runners - 15 runners with varied backgrounds
  const runners = [
    {
      email: 'alex.rivera@ultracoach.dev',
      name: 'Alex Rivera',
      fullName: 'Alex Rivera',
      experience: 'beginner',
    },
    {
      email: 'jordan.chen@ultracoach.dev',
      name: 'Jordan Chen',
      fullName: 'Jordan Chen',
      experience: 'intermediate',
    },
    {
      email: 'casey.johnson@ultracoach.dev',
      name: 'Casey Johnson',
      fullName: 'Casey Johnson',
      experience: 'advanced',
    },
    {
      email: 'taylor.smith@ultracoach.dev',
      name: 'Taylor Smith',
      fullName: 'Taylor Smith',
      experience: 'beginner',
    },
    {
      email: 'morgan.davis@ultracoach.dev',
      name: 'Morgan Davis',
      fullName: 'Morgan Davis',
      experience: 'intermediate',
    },
    {
      email: 'riley.parker@ultracoach.dev',
      name: 'Riley Parker',
      fullName: 'Riley Parker',
      experience: 'beginner',
    },
    {
      email: 'quinn.wilson@ultracoach.dev',
      name: 'Quinn Wilson',
      fullName: 'Quinn Wilson',
      experience: 'advanced',
    },
    {
      email: 'blake.torres@ultracoach.dev',
      name: 'Blake Torres',
      fullName: 'Blake Torres',
      experience: 'intermediate',
    },
    {
      email: 'dakota.lee@ultracoach.dev',
      name: 'Dakota Lee',
      fullName: 'Dakota Lee',
      experience: 'beginner',
    },
    {
      email: 'sage.rodriguez@ultracoach.dev',
      name: 'Sage Rodriguez',
      fullName: 'Sage Rodriguez',
      experience: 'intermediate',
    },
    {
      email: 'river.martinez@ultracoach.dev',
      name: 'River Martinez',
      fullName: 'River Martinez',
      experience: 'advanced',
    },
    {
      email: 'phoenix.garcia@ultracoach.dev',
      name: 'Phoenix Garcia',
      fullName: 'Phoenix Garcia',
      experience: 'beginner',
    },
    {
      email: 'skylar.anderson@ultracoach.dev',
      name: 'Skylar Anderson',
      fullName: 'Skylar Anderson',
      experience: 'intermediate',
    },
    {
      email: 'rowan.thompson@ultracoach.dev',
      name: 'Rowan Thompson',
      fullName: 'Rowan Thompson',
      experience: 'advanced',
    },
    {
      email: 'nova.clark@ultracoach.dev',
      name: 'Nova Clark',
      fullName: 'Nova Clark',
      experience: 'beginner',
    },
  ].map(runner => ({
    ...runner,
    password: process.env.TEST_RUNNER_PASSWORD || 'RunnerPass2025!',
    role: 'runner' as const,
  }))

  return [...coaches, ...runners]
}

// --- Database Setup ---
// Use the unified database connection from our main database module
// This ensures consistency with Better Auth and the rest of the application

// --- Static Data Functions ---
async function seedStaticData() {
  // Use the unified database connection
  logger.info('üìã Seeding static data (training phases and plan templates)...')

  // Seed training phases
  for (const phaseData of trainingPhasesData) {
    try {
      const existingPhase = await db
        .select()
        .from(schema.training_phases)
        .where(eq(schema.training_phases.name, phaseData.name))
        .limit(1)

      if (existingPhase.length > 0) {
        logger.info(`Training phase "${phaseData.name}" already exists, skipping...`)
        continue
      }

      await db.insert(schema.training_phases).values(phaseData)
      logger.info(`‚úÖ Created training phase: ${phaseData.name}`)
    } catch (error) {
      logger.error(`‚ùå Failed to create training phase "${phaseData.name}":`, error)
    }
  }

  // Seed plan templates
  for (const templateData of planTemplatesData) {
    try {
      const existingTemplate = await db
        .select()
        .from(schema.plan_templates)
        .where(eq(schema.plan_templates.name, templateData.name))
        .limit(1)

      if (existingTemplate.length > 0) {
        logger.info(`Plan template "${templateData.name}" already exists, skipping...`)
        continue
      }

      // Transform the data to match the database schema
      const dbTemplateData = {
        name: templateData.name,
        description: templateData.description,
        distance_type: templateData.distanceType,
        duration_weeks: templateData.durationWeeks,
        difficulty_level: templateData.difficultyLevel,
        peak_weekly_miles: templateData.peakWeeklyMiles,
        min_base_miles: templateData.minBaseMiles,
        is_public: templateData.isPublic,
        tags: templateData.tags,
      }

      await db.insert(schema.plan_templates).values(dbTemplateData)
      logger.info(`‚úÖ Created plan template: ${templateData.name}`)
    } catch (error) {
      logger.error(`‚ùå Failed to create plan template "${templateData.name}":`, error)
    }
  }
}

// --- Better Auth User Creation ---
async function seedTestUsers() {
  // Use the unified database connection
  logger.info('üë• Creating test users using Better Auth Admin API...')

  // Security warning for production
  if (process.env.NODE_ENV === 'production') {
    logger.warn('‚ö†Ô∏è  WARNING: Creating test users in production environment!')
    logger.warn('‚ö†Ô∏è  Ensure test user credentials are secure and monitored!')
  }

  const testUsersData = getTestUsersData()

  // Import Better Auth instance
  const { auth } = await import('../src/lib/better-auth')

  for (const userData of testUsersData) {
    try {
      logger.info(`Creating user: ${userData.email}`)

      // Check if user already exists first
      const existingUser = await db
        .select()
        .from(schema.user)
        .where(eq(schema.user.email, userData.email))
        .limit(1)

      if (existingUser.length > 0) {
        logger.info(`User ${userData.email} already exists, skipping...`)
        continue
      }

      // Use direct database insertion with Better Auth patterns
      // Generate a proper user ID
      const userId = generateRandomString(10)

      // Insert user directly into database
      await db.insert(schema.user).values({
        id: userId,
        email: userData.email,
        name: userData.name,
        role: 'user', // Better Auth standard role
        userType: userData.role, // Our application-specific role (coach/runner)
        fullName: userData.fullName,
        emailVerified: false, // Set appropriate verification status
        createdAt: new Date(),
        updatedAt: new Date(),
      })

      logger.info(`‚úÖ Created user: ${userData.email} (${userData.role})`)

      // Create credential account for password authentication
      // Import Better Auth instance to access password hashing
      const { auth } = await import('../src/lib/better-auth')

      // Use Better Auth's internal password hashing
      const hashedPassword =
        (await auth.options.emailAndPassword?.password?.hash?.(userData.password)) ||
        (await defaultHash(userData.password))

      await db.insert(schema.account).values({
        id: generateRandomString(10),
        accountId: userId, // Link to the user
        providerId: 'credential', // Important: Must be 'credential' for email/password
        userId: userId,
        password: hashedPassword,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      logger.info(`‚úÖ Created credential account for: ${userData.email}`)
    } catch (error) {
      logger.error(`üö® EXCEPTION while creating user ${userData.email}:`, error)
    }
  }
}

// --- Coach-Runner Relationships ---
async function createCoachRunnerRelationships() {
  logger.info('ü§ù Creating coach-runner relationships...')

  const users = await db.select().from(schema.user)
  const coaches = users.filter(user => user.userType === 'coach')
  const runners = users.filter(user => user.userType === 'runner')

  if (coaches.length === 0 || runners.length === 0) {
    logger.warn('‚ö†Ô∏è No coaches or runners found - skipping relationship creation')
    return
  }

  // Connect 1 runner to each coach (3 active relationships)
  // Connect runners 0, 5, 10 (one from each group of 5)
  const connectedRunnerIndices = [0, 5, 10]

  for (let i = 0; i < Math.min(coaches.length, connectedRunnerIndices.length); i++) {
    const coach = coaches[i]
    const runnerIndex = connectedRunnerIndices[i]

    if (runnerIndex < runners.length) {
      const runner = runners[runnerIndex]

      try {
        // Check if relationship already exists
        const existingRelationship = await db
          .select()
          .from(schema.coach_runners)
          .where(
            and(
              eq(schema.coach_runners.coach_id, coach.id),
              eq(schema.coach_runners.runner_id, runner.id)
            )
          )
          .limit(1)

        if (existingRelationship.length > 0) {
          logger.info(
            `Relationship between ${coach.name} and ${runner.name} already exists, skipping...`
          )
          continue
        }

        // Create active coach-runner relationship
        await db.insert(schema.coach_runners).values({
          id: randomUUID(),
          coach_id: coach.id,
          runner_id: runner.id,
          status: 'active',
          relationship_type: 'standard',
          invited_by: null,
          relationship_started_at: new Date(),
          notes: `Connected during comprehensive seeding - ${coach.name} coaching ${runner.name}`,
          created_at: new Date(),
          updated_at: new Date(),
        })

        logger.info(`‚úÖ Connected ${coach.name} ‚Üî ${runner.name}`)
      } catch (error) {
        logger.error(
          `‚ùå Failed to create relationship between ${coach.name} and ${runner.name}:`,
          error
        )
      }
    }
  }

  logger.info(
    `‚úÖ Created relationships for ${Math.min(coaches.length, connectedRunnerIndices.length)} coach-runner pairs`
  )
}

// --- Training Plans & Sample Data Seeding ---
async function createSampleTrainingPlan() {
  // Use the unified database connection
  logger.info('üèÉ Creating sample training plans for connected coach-runner pairs...')

  // Get coach and runners
  const users = await db.select().from(schema.user)
  const coaches = users.filter(user => user.userType === 'coach')
  const runners = users.filter(user => user.userType === 'runner')

  // Get connected relationships
  const relationships = await db
    .select()
    .from(schema.coach_runners)
    .where(eq(schema.coach_runners.status, 'active'))

  if (coaches.length === 0 || runners.length === 0 || relationships.length === 0) {
    logger.warn(
      '‚ö†Ô∏è No connected coach-runner relationships found - skipping training plan creation'
    )
    return
  }

  // Training plan templates based on coach specialties
  const trainingPlanTemplates = [
    {
      title: 'Alpine 100-Mile Mastery',
      description:
        'Comprehensive 20-week program for tackling 100-mile mountain races with technical terrain and elevation gain.',
      target_distance: '100M',
    },
    {
      title: '50K Trail Domination',
      description:
        '12-week speed-focused plan for conquering your first or fastest 50K trail race.',
      target_distance: '50K',
    },
    {
      title: 'Backcountry 50-Mile Journey',
      description:
        '16-week holistic training approach combining physical preparation with mental resilience and fueling strategies.',
      target_distance: '50M',
    },
  ]

  for (let i = 0; i < Math.min(relationships.length, trainingPlanTemplates.length); i++) {
    const relationship = relationships[i]
    const template = trainingPlanTemplates[i]
    const coach = coaches.find(c => c.id === relationship.coach_id)
    const runner = runners.find(r => r.id === relationship.runner_id)

    if (!coach || !runner) continue

    const planData = {
      title: template.title,
      description: template.description,
      coach_id: coach.id,
      runner_id: runner.id,
      target_race_date: addDays(new Date(), 140), // ~20 weeks out
      target_race_distance: template.target_distance,
    }

    try {
      const existingPlan = await db
        .select()
        .from(schema.training_plans)
        .where(eq(schema.training_plans.title, planData.title))
        .limit(1)

      if (existingPlan.length > 0) {
        logger.info(`Training plan "${planData.title}" already exists, skipping...`)
        continue
      }

      const [newPlan] = await db.insert(schema.training_plans).values(planData).returning()
      logger.info(
        `‚úÖ Created training plan: "${planData.title}" (Coach: ${coach.email}, Runner: ${runner.email})`
      )

      // Create sample workouts for each training plan
      await seedSampleWorkouts(newPlan.id, planData.title)
    } catch (error) {
      logger.error(`üö® Failed to create training plan "${planData.title}":`, error)
    }
  }
}

// --- Sample Workouts Seeding ---
async function seedSampleWorkouts(trainingPlanId: string, planTitle: string) {
  // Use the unified database connection
  const currentDate = new Date()

  // Get the training plan to find the runner_id
  const [plan] = await db
    .select()
    .from(schema.training_plans)
    .where(eq(schema.training_plans.id, trainingPlanId))

  if (!plan) {
    logger.error(`‚ùå Training plan not found for ID: ${trainingPlanId}`)
    return
  }

  const workoutsData = [
    {
      training_plan_id: trainingPlanId,
      user_id: plan.runner_id, // Required field - associate workout with runner
      title: `Easy Run - ${format(addDays(currentDate, 1), 'MMM dd')}`, // Required field
      date: startOfDay(addDays(currentDate, 1)), // Tomorrow
      planned_distance: '5.00',
      planned_duration: 45, // 45 minutes (stored as minutes)
      planned_type: 'Easy Run',
      status: 'planned' as const,
      // Enhanced workout fields
      category: 'easy',
      intensity: 3,
      terrain: 'road',
      elevation_gain: 100,
    },
    {
      training_plan_id: trainingPlanId,
      user_id: plan.runner_id, // Required field
      title: `Tempo Run - ${format(addDays(currentDate, 3), 'MMM dd')}`, // Required field
      date: startOfDay(addDays(currentDate, 3)), // 3 days from now
      planned_distance: '8.00',
      planned_duration: 60, // 60 minutes
      planned_type: 'Tempo Run',
      status: 'planned' as const,
      // Enhanced workout fields
      category: 'tempo',
      intensity: 7,
      terrain: 'road',
      elevation_gain: 200,
    },
    {
      training_plan_id: trainingPlanId,
      user_id: plan.runner_id, // Required field
      title: `Long Run - ${format(addDays(currentDate, 6), 'MMM dd')}`, // Required field
      date: startOfDay(addDays(currentDate, 6)), // 6 days from now
      planned_distance: '12.00',
      planned_duration: 90, // 90 minutes
      planned_type: 'Long Run',
      status: 'planned' as const,
      // Enhanced workout fields
      category: 'long_run',
      intensity: 5,
      terrain: 'trail',
      elevation_gain: 500,
    },
  ]

  try {
    await db.insert(schema.workouts).values(workoutsData)
    logger.info(`  ‚úÖ Added ${workoutsData.length} sample workouts for "${planTitle}"`)
    logger.info(
      `  üìÖ Workout dates: ${workoutsData.map(w => format(w.date, 'yyyy-MM-dd')).join(', ')}`
    )
  } catch (error) {
    logger.error(`  ‚ùå Failed to create sample workouts for "${planTitle}":`, error)
  }
}

// --- Conversations Seeding ---
async function seedConversations() {
  // Use the unified database connection
  logger.info('üí¨ Creating sample conversations between coaches and runners...')

  // Get all users and training plans
  const users = await db.select().from(schema.user)
  const coaches = users.filter(user => user.userType === 'coach')
  const runners = users.filter(user => user.userType === 'runner')
  const trainingPlans = await db.select().from(schema.training_plans)

  if (coaches.length === 0 || runners.length === 0 || trainingPlans.length === 0) {
    logger.warn('‚ö†Ô∏è Insufficient data for conversations - skipping conversation creation')
    return
  }

  // Create conversations
  const conversationsData = [
    {
      coach_id: coaches[0].id, // Elena Rodriguez
      runner_id: runners[0].id, // Alex Trail
      training_plan_id: trainingPlans[0].id,
      title: 'Training Progress Check-in',
    },
    {
      coach_id: coaches[1].id, // Sarah Mountain
      runner_id: runners[1].id, // Mike Trailblazer
      training_plan_id: trainingPlans[1].id,
      title: 'Trail Running Technique Discussion',
    },
  ]

  for (const convData of conversationsData) {
    try {
      const existingConv = await db
        .select()
        .from(schema.conversations)
        .where(eq(schema.conversations.title, convData.title))
        .limit(1)

      if (existingConv.length > 0) {
        logger.info(`Conversation "${convData.title}" already exists, skipping...`)
        continue
      }

      const [newConv] = await db.insert(schema.conversations).values(convData).returning()
      const coach = coaches.find(c => c.id === convData.coach_id)
      const runner = runners.find(r => r.id === convData.runner_id)
      logger.info(
        `‚úÖ Created conversation: "${convData.title}" (${coach?.name} ‚Üî ${runner?.name})`
      )
    } catch (error) {
      logger.error(`üö® Failed to create conversation "${convData.title}":`, error)
    }
  }
}

// --- Main Execution ---
async function main() {
  const startTime = Date.now()

  try {
    logger.info('üå± Starting UltraCoach database seeding...')

    // Clean up old password files first
    cleanupPasswordFiles()

    // Get test user data and update .env.local
    const testUsersData = getTestUsersData()
    updateEnvLocal(testUsersData)

    // Seed static data first
    await seedStaticData()

    // Create test users
    await seedTestUsers()

    // Create coach-runner relationships
    await createCoachRunnerRelationships()

    // Create sample training plans with relationships
    await createSampleTrainingPlan()

    // Create sample conversations
    await seedConversations()

    // Show summary
    logger.info('üìä Database summary:')
    const userCount = await db
      .select()
      .from(schema.user)
      .then(r => r.length)
    const planCount = await db
      .select()
      .from(schema.training_plans)
      .then(r => r.length)
    const workoutCount = await db
      .select()
      .from(schema.workouts)
      .then(r => r.length)
    const phaseCount = await db
      .select()
      .from(schema.training_phases)
      .then(r => r.length)
    const templateCount = await db
      .select()
      .from(schema.plan_templates)
      .then(r => r.length)

    logger.info('üìä Seeding Results:', {
      users: userCount,
      trainingPlans: planCount,
      workouts: workoutCount,
      trainingPhases: phaseCount,
      planTemplates: templateCount,
    })

    // Database connection will be cleaned up automatically by the unified database module

    const duration = Date.now() - startTime
    logger.info(`‚úÖ Database seeding completed in ${duration}ms`)

    logger.info('üéØ Database seeding completed successfully!', {
      status: 'complete',
      features: [
        'Test users created with secure credentials',
        'Coach-runner relationships established',
        'Training plans and sample workouts added',
        'Credentials saved to .env.local for easy testing',
        'Old password files cleaned up for security',
      ],
    })
  } catch (error) {
    logger.error('‚ùå Database seeding failed:', error)
    // In test environment, don't exit process
    if (process.env.NODE_ENV === 'test') {
      throw error
    }
    process.exit(1)
  }
}

// Only run main() if not in test environment or when required directly
if (process.env.NODE_ENV !== 'test' && require.main === module) {
  main()
}

// Export for testing
export { main as seedDatabase }
