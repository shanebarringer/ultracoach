/**
 * Workouts Atoms Unit Tests
 * 
 * Tests the workout-related atoms:
 * - workoutsAtom
 * - filteredWorkoutsAtom
 * - workoutsRefreshTriggerAtom
 * - createWorkoutActionAtom
 * - updateWorkoutActionAtom
 * - deleteWorkoutActionAtom
 * - markWorkoutCompleteAtom
 * - bulkWorkoutOperationsAtom
 */

import { createStore } from 'jotai'
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import {
  workoutsAtom,
  filteredWorkoutsAtom,
  workoutFiltersAtom,
  workoutsRefreshTriggerAtom,
  createWorkoutActionAtom,
  updateWorkoutActionAtom,
  deleteWorkoutActionAtom,
  markWorkoutCompleteAtom,
  bulkWorkoutOperationsAtom,
  workoutsLoadingAtom,
  selectedWorkoutIdsAtom
} from '@/lib/atoms/workouts'
import { sessionAtom } from '@/lib/atoms/auth'
import {
  createTestStore,
  getAtomValue,
  setAtomValue,
  createMockSession,
  createMockWorkout,
  mockFetch,
  setupCommonMocks
} from './utils/test-helpers'

describe('Workouts Atoms', () => {
  let store: ReturnType<typeof createStore>
  let cleanup: () => void
  let fetchMock: ReturnType<typeof mockFetch>

  beforeEach(() => {
    const mocks = setupCommonMocks()
    cleanup = mocks.cleanup
    store = createTestStore()
    
    // Set up mock session
    const mockSession = createMockSession({
      user: { id: 'test-user-id', userType: 'runner' }
    })
    setAtomValue(store, sessionAtom, mockSession)
  })

  afterEach(() => {
    cleanup()
    vi.restoreAllMocks()
  })

  describe('workoutsAtom', () => {
    it('should have empty array as initial value', () => {
      const workouts = getAtomValue(store, workoutsAtom)
      expect(workouts).toEqual([])
    })

    it('should store workouts', () => {
      const mockWorkouts = [
        createMockWorkout({ id: 'w1', name: 'Morning Run' }),
        createMockWorkout({ id: 'w2', name: 'Afternoon Workout' })
      ]
      
      setAtomValue(store, workoutsAtom, mockWorkouts)
      
      const workouts = getAtomValue(store, workoutsAtom)
      expect(workouts).toHaveLength(2)
      expect(workouts[0].name).toBe('Morning Run')
      expect(workouts[1].name).toBe('Afternoon Workout')
    })
  })

  describe('filteredWorkoutsAtom', () => {
    beforeEach(() => {
      // Set up test workouts
      const workouts = [
        createMockWorkout({ 
          id: 'w1', 
          type: 'long_run', 
          status: 'planned',
          date: '2024-01-01T10:00:00Z'
        }),
        createMockWorkout({ 
          id: 'w2', 
          type: 'interval', 
          status: 'completed',
          date: '2024-01-02T10:00:00Z'
        }),
        createMockWorkout({ 
          id: 'w3', 
          type: 'long_run', 
          status: 'completed',
          date: '2024-01-03T10:00:00Z'
        })
      ]
      setAtomValue(store, workoutsAtom, workouts)
    })

    it('should return all workouts when no filters', () => {
      setAtomValue(store, workoutFiltersAtom, {})
      const filtered = getAtomValue(store, filteredWorkoutsAtom)
      expect(filtered).toHaveLength(3)
    })

    it('should filter by workout type', () => {
      setAtomValue(store, workoutFiltersAtom, { type: 'long_run' })
      const filtered = getAtomValue(store, filteredWorkoutsAtom)
      
      expect(filtered).toHaveLength(2)
      expect(filtered.every(w => w.type === 'long_run')).toBe(true)
    })

    it('should filter by status', () => {
      setAtomValue(store, workoutFiltersAtom, { status: 'completed' })
      const filtered = getAtomValue(store, filteredWorkoutsAtom)
      
      expect(filtered).toHaveLength(2)
      expect(filtered.every(w => w.status === 'completed')).toBe(true)
    })

    it('should filter by date range', () => {
      setAtomValue(store, workoutFiltersAtom, {
        startDate: '2024-01-02',
        endDate: '2024-01-03'
      })
      const filtered = getAtomValue(store, filteredWorkoutsAtom)
      
      expect(filtered).toHaveLength(2)
      expect(filtered[0].id).toBe('w2')
      expect(filtered[1].id).toBe('w3')
    })

    it('should apply multiple filters', () => {
      setAtomValue(store, workoutFiltersAtom, {
        type: 'long_run',
        status: 'completed'
      })
      const filtered = getAtomValue(store, filteredWorkoutsAtom)
      
      expect(filtered).toHaveLength(1)
      expect(filtered[0].id).toBe('w3')
    })
  })

  describe('createWorkoutActionAtom', () => {
    beforeEach(() => {
      fetchMock = mockFetch(new Map([
        ['/api/workouts', {
          ok: true,
          json: () => Promise.resolve({
            workout: createMockWorkout({
              id: 'new-workout',
              name: 'New Workout'
            })
          })
        }]
      ]))
    })

    it('should create a new workout', async () => {
      const workoutData = {
        name: 'New Workout',
        type: 'long_run',
        date: '2024-01-05',
        distance: 10,
        duration: 60
      }
      
      const result = await store.set(createWorkoutActionAtom, workoutData)
      
      expect(fetchMock).toHaveBeenCalledWith('/api/workouts', expect.objectContaining({
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(workoutData)
      }))
      
      expect(result.workout.id).toBe('new-workout')
    })

    it('should update workouts list after creation', async () => {
      setAtomValue(store, workoutsAtom, [])
      
      const workoutData = {
        name: 'New Workout',
        type: 'long_run' as const,
        date: '2024-01-05'
      }
      
      await store.set(createWorkoutActionAtom, workoutData)
      
      const workouts = getAtomValue(store, workoutsAtom)
      expect(workouts).toHaveLength(1)
      expect(workouts[0].name).toBe('New Workout')
    })
  })

  describe('updateWorkoutActionAtom', () => {
    beforeEach(() => {
      const existingWorkout = createMockWorkout({ 
        id: 'w1', 
        name: 'Original Name' 
      })
      setAtomValue(store, workoutsAtom, [existingWorkout])
      
      fetchMock = mockFetch(new Map([
        ['/api/workouts/w1', {
          ok: true,
          json: () => Promise.resolve({
            workout: { ...existingWorkout, name: 'Updated Name' }
          })
        }]
      ]))
    })

    it('should update an existing workout', async () => {
      const updateData = {
        id: 'w1',
        updates: { name: 'Updated Name' }
      }
      
      const result = await store.set(updateWorkoutActionAtom, updateData)
      
      expect(fetchMock).toHaveBeenCalledWith('/api/workouts/w1', expect.objectContaining({
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: 'Updated Name' })
      }))
      
      expect(result.workout.name).toBe('Updated Name')
    })

    it('should update workout in the list', async () => {
      await store.set(updateWorkoutActionAtom, {
        id: 'w1',
        updates: { name: 'Updated Name' }
      })
      
      const workouts = getAtomValue(store, workoutsAtom)
      expect(workouts[0].name).toBe('Updated Name')
    })
  })

  describe('deleteWorkoutActionAtom', () => {
    beforeEach(() => {
      const workouts = [
        createMockWorkout({ id: 'w1' }),
        createMockWorkout({ id: 'w2' })
      ]
      setAtomValue(store, workoutsAtom, workouts)
      
      fetchMock = mockFetch(new Map([
        ['/api/workouts/w1', {
          ok: true,
          json: () => Promise.resolve({ success: true })
        }]
      ]))
    })

    it('should delete a workout', async () => {
      await store.set(deleteWorkoutActionAtom, 'w1')
      
      expect(fetchMock).toHaveBeenCalledWith('/api/workouts/w1', expect.objectContaining({
        method: 'DELETE'
      }))
      
      const workouts = getAtomValue(store, workoutsAtom)
      expect(workouts).toHaveLength(1)
      expect(workouts[0].id).toBe('w2')
    })
  })

  describe('markWorkoutCompleteAtom', () => {
    beforeEach(() => {
      const workout = createMockWorkout({ 
        id: 'w1', 
        status: 'planned' 
      })
      setAtomValue(store, workoutsAtom, [workout])
      
      fetchMock = mockFetch(new Map([
        ['/api/workouts/w1/complete', {
          ok: true,
          json: () => Promise.resolve({
            workout: { ...workout, status: 'completed' }
          })
        }]
      ]))
    })

    it('should mark workout as complete', async () => {
      const completionData = {
        id: 'w1',
        actualDistance: 10.5,
        actualDuration: 65,
        notes: 'Felt good!'
      }
      
      await store.set(markWorkoutCompleteAtom, completionData)
      
      expect(fetchMock).toHaveBeenCalledWith('/api/workouts/w1/complete', expect.objectContaining({
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          actualDistance: 10.5,
          actualDuration: 65,
          notes: 'Felt good!'
        })
      }))
      
      const workouts = getAtomValue(store, workoutsAtom)
      expect(workouts[0].status).toBe('completed')
    })
  })

  describe('bulkWorkoutOperationsAtom', () => {
    beforeEach(() => {
      const workouts = [
        createMockWorkout({ id: 'w1', status: 'planned' }),
        createMockWorkout({ id: 'w2', status: 'planned' }),
        createMockWorkout({ id: 'w3', status: 'completed' })
      ]
      setAtomValue(store, workoutsAtom, workouts)
      
      fetchMock = mockFetch(new Map([
        ['/api/workouts/bulk', {
          ok: true,
          json: () => Promise.resolve({
            updated: ['w1', 'w2'],
            deleted: []
          })
        }]
      ]))
    })

    it('should perform bulk update operation', async () => {
      const bulkOp = {
        operation: 'update' as const,
        workoutIds: ['w1', 'w2'],
        updates: { status: 'completed' as const }
      }
      
      await store.set(bulkWorkoutOperationsAtom, bulkOp)
      
      expect(fetchMock).toHaveBeenCalledWith('/api/workouts/bulk', expect.objectContaining({
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(bulkOp)
      }))
    })

    it('should perform bulk delete operation', async () => {
      fetchMock = mockFetch(new Map([
        ['/api/workouts/bulk', {
          ok: true,
          json: () => Promise.resolve({
            updated: [],
            deleted: ['w1', 'w2']
          })
        }]
      ]))
      
      const bulkOp = {
        operation: 'delete' as const,
        workoutIds: ['w1', 'w2']
      }
      
      await store.set(bulkWorkoutOperationsAtom, bulkOp)
      
      const workouts = getAtomValue(store, workoutsAtom)
      expect(workouts).toHaveLength(1)
      expect(workouts[0].id).toBe('w3')
    })
  })

  describe('workoutsRefreshTriggerAtom', () => {
    it('should trigger refresh', async () => {
      fetchMock = mockFetch(new Map([
        ['/api/workouts', {
          ok: true,
          json: () => Promise.resolve({
            workouts: [
              createMockWorkout({ id: 'fresh-1' }),
              createMockWorkout({ id: 'fresh-2' })
            ]
          })
        }]
      ]))
      
      await store.set(workoutsRefreshTriggerAtom)
      
      expect(fetchMock).toHaveBeenCalledWith('/api/workouts')
      
      const workouts = getAtomValue(store, workoutsAtom)
      expect(workouts).toHaveLength(2)
      expect(workouts[0].id).toBe('fresh-1')
    })
  })

  describe('selectedWorkoutIdsAtom', () => {
    it('should track selected workout IDs', () => {
      setAtomValue(store, selectedWorkoutIdsAtom, new Set(['w1', 'w2']))
      
      const selected = getAtomValue(store, selectedWorkoutIdsAtom)
      expect(selected.has('w1')).toBe(true)
      expect(selected.has('w2')).toBe(true)
      expect(selected.size).toBe(2)
    })
  })

  describe('workoutsLoadingAtom', () => {
    it('should track loading state', () => {
      setAtomValue(store, workoutsLoadingAtom, true)
      expect(getAtomValue(store, workoutsLoadingAtom)).toBe(true)
      
      setAtomValue(store, workoutsLoadingAtom, false)
      expect(getAtomValue(store, workoutsLoadingAtom)).toBe(false)
    })
  })
})